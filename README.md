# SpringBoot-JPA1

### 웹 어플리케이션 개발 단계
1. 프로젝트 환경 설정
2. 요구사항 분석
3. 도메인과 테이블 설계
4. 아키텍쳐 구성
5. 핵심 비지니스 로직 개발(회원, 상품, 주문)
6. 테스트
7. 웹 계층 개발

### 프로젝트 환경 설정
* Dependancies 추가 및 H2 DB연결
* Test코드로 접속 상태 확인
* 필요한 엔티티 생성 및 설정 추가

### 요구사항 분석
* 회원 기능
  - 회원 등록
  - 회원 조회
* 상품 기능
  - 상품 득록
  - 상품 목록
* 주무 기능
  - 상품 주문
  - 주문 내역

### 아키텍처 구성
* 계층형 구조 사용
  - controller, web : 웹계층
  - service : 비지니스 로직, 트랜잭션 처리
  - repository : JPA를 직접 사용하는 계층, 엔티티 매니저 사용
  - domain : 엔티티가 모여있는 계층, 모든 계층에서 사용
  
* 패키지 구조
  - jpabook.jpashop
    + domain
    + exception
    + repository
    + service
    + web
    
* 개발 순서 : 서비스, 리포지토리 계층을 먼저 개발하고, 테스트 케이스를 작성해서 검증하고 마지막에 웹 계층 구현

### 핵심 비지니스 로직 개발

##### 도메인 모델 패턴 : 대부분의 비지니스 로직을 엔티티에 만들어 두고 사용하는 것. 이 패턴은 객체지향의 특성을 적극 활용한다. 서비스 계층은 단순히 엔티티에 필요하 요청을 위임하는 역할을 한다.
##### 트랜잭션 스크립트 패턴 : 도메인 모델 패턴과 반대로 엔티티에는 비지니스 로직이 거의 없고, 서비스 계층에서 대부분의 비지니스 로직을 처리하는 패턴.

* 회원 도메인 개발
  - 회원 등록
  - 회원 목록 조회
  
* 회원 기능 테스트
  - 회원가입을 성공해야 한다.
  - 회원가입 시 같은 이름이 있으면 예외 발생해야 한다.
  
* 상품 도메인 개발
  - 상품 등록
  - 상품 목록 조회
  - 상품 수정

* 주문 도메인 개발
  - 상품 주문
    + Order의 멤버필드 중 CascadeType.All 옵션이 걸려있는 필드는 Order가 persist될 때, 같이 persist된다.
    + cascade를 사용하는 범위는 Order가 Delivery를 관리하고 OrderItem을 관리하는 관계 정도에서만 사용하는 것이 좋다. private honor이 경우에 사용하는 것이 좋다.
  - 주문 내역 조회
  - 주문 취소

* 주문 검색 기능 개발
  - 주문 검색 조회
    + JPA에 '동적 쿼리'를 어떻게 해결해야 하는가?
    
* 웹 계층 개발
    - 회원 등록 및 목록 화면 구현
    - 상품 등록 및 목록, 수정 화면 구현
    - 주문 등록 및 주문 목록과 취소 화면 구현
    - 주문 검색 기능 구현

##### 변경감지와 병합(merge)

* 준영속 엔티티란? 
영속성 컨텍스트가 더 이상 관리하지 않는 엔티티.

* 준영속 엔티티를 수정하는 2가지 방법
    - 변경 감지(dirty checking) 사용
        + 영속성 컨텍스트에서 엔티티를 다시 조회한 후에 데이터를 수정하는 방법(트랜잭션에 의해 커밋되는 시점에서 자동 업데이트(flush) 됨)
    - 병합(merge) 사용
        + 병합은 준영속상태의 엔티티를 영속상태로 변경할 때 사용하는 기능
        + EntityManager.merge();
        + 병합 시 주의사항 : 변경감지와 다르게 병합은 모든 속성이 변경된다. 병합시 값이 없으면 null로 업데이트 된다..
        + 실무에서는 엔티티를 변경할 땐 꼭 변경감지를 사용 할 것.
        
# SpringBoot-JPA2

### REST API 개발
* 등록, 수정, 조회 REST API 개발
* API 개발 실무 노하우(성능 최적화)

* API 기본
    - 회원 등록
    - 회원 수정
    - 회원 조회 
    
##### API 통신 시, 절대로 엔티티를 노출시키지 말 것. 따로 DTO를 생성해서 사용하는 것이 좋음.

* API 개발 고급
    - 조회용 샘플 데이터 입력 (3/18)
    - 지연 로딩과 조회 성능 최적화 (3/19)
        + 엔티티를 직접 노출하는 경우, 양방향 연관관계가 걸려있으면 무조건 한쪽에 @JsonIgnore을 설정해야 함. 그렇지 않으면 무한루프에 빠지게 됨.
        + 간단한 어플리케이션이 아닌 경우 엔티티를 그대로 외부에 노출하면 안됨. Hibernate5Module을 사용하는 것 보다는 DTO를 만들어 사용하는게 좋음. 
        + 지연로딩(LAZY)을 피하기 위해 즉시로딩(EAGER)을 하면 안됨. 즉시로딩으로 설정하 성능 튜닝이 매우 어려워 짐.
    - 페치조인(fetch join): inner join으로 변형되어 쿼리를 1번만 조회함
        + 페치조인으로 order -> member, order -> delivery는 이미 조회된 상태이므로 지연로딩은 발생하지 않음.
        + simple orderV3와 orderV4는 각각의 장단이 있기 때문에 한쪽만 더 낫다고 판단하기 어려움.
        + orderV4의 경우 JPQL에서 new를 사용해 원하는 값들만 가져올 수 있는 장점이 있지만 리포지토리의 재사용성이 떨어지고 API스펙에 맞춘 코드가 리포지토리에 들어간다는 단점이 있음. 
    - 컬렉션 조회 최적화
        + 양방향 연관관계에서 호출되는 쪽에 @JsonIgnore를 붙여주지 않으면 무한루프에 빠지게 됨.
        + 일대다 연관관계에서 fetch join을 사용하면 페이징 처리가 불가능함.
        + 컬렉션 fetch join은 1개만 사용할 수 있음. 컬렉션 2개 이상에 사용하면 데이터가 부정합하게 조회될 수 있음.
    - 페이징과 한계 돌파
    - OSIV(Opne Session In View)와 성능 최적화 
        + spring.jpa.open-in-view(true가 기본값)
        + OSIV전략은 트랜잭션 시작처럼 최초 데이터베이스 커넥션 시작 시점부터 API 응답이 끋날 때까지 영속성 컨텍스트와 DB 커넥션을 유지함.
        + 너무 오랫동안 DB 커넥션을 이용하기 때문에 실시간 트래픽이 중요한 애플리케이션에서는 커넥션이 부족해질 수 있음.
        + OSIV를 종료시키면 커넥션 리소스를 낭비하지 않는다는 장점은 있지만, 모든 지연로딩을 트랜잭션 안에서 처리해야 한다는 단점이 있음.
        + 실시간 API통신이 많은 경우엔 OSIV를 끄고, ADMIN처럼 커넥션이 많지 않은 경우엔 OSIV를 켜는것을 권장함.(상황에 따라 다르게 판단)
    
##### 쿼리 방식 선택 권장 순서
1. 우선 엔티티를 DTO로 변환하는 방법을 선택한다. (v2)
2. 필요하면 패치조인으로 성능을 최적화 한다. (v3, 여기에서 대부분(95%)의 성능이슈는 해결 됨)
3. 그래도 안되면 DTO로 조회하는 방법을 사용한다. (v4)
4. 최후의 방법은 JPA가 제공하는 네이티브 SQL이나 스프링 JDBCTemplate을 사용해서 SQL을 직접 사용한다.(v5, 쿼리문이 1번만 나가도록 최적화 함.)

##### distinct 키워드의 2가지 기능
1. DB에 distinct 키워드를 날려줌. (원래 sql의 distinct는 모든 컬럼의 값이 동일해야 중복으로 인식함.)
2. 루트 엔티티가 중복인 경우에 중복을 제거해서 컬렉션에 담아 줌.

##### select query 조회 시 주의할 점
1. ToOne(ManayToOne, OneToOne)관계는 모두 fetch join함.(왜냐면 데이터가 뻥튀기 되지 않으니까)
2. 컬렉션은 지연로딩으로 조회함.
3. 지연 로딩 성능 최적화를 위해서 hibernate.default_batch_fetch_size나 @BatchSize를 적용함.
    => 이 옵션들을 사용하면 컬렉션이나 프록시 객체를 설정한 size만큼 한번에 IN query로 조회함.
    -  hibernate.default_batch_fetch_size는 글로벌 설정
    - @BatchSize는 클래스나 메서드에 붙여주는 개별 최적화
        + 장점
        + 쿼리 호출 수가 1 + N 에서 1 + 1로 최적화 됨.
        + 조인보다 DB데이터 전송량이 최적화 됨.
        + v3방법은 페이징이 불가능하지만 v3.1방법은 페이징이 가능함.
        
### JPA의 EntityManager가 Hibernate에선 Session임.


* Querydsl
